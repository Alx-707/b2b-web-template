import * as React from 'react';

/**
 * Animation constants to avoid magic numbers
 */
const ANIMATION_CONSTANTS = {
  HALF_POINT: 0.5,
  DOUBLE_MULTIPLIER: 2,
  CUBIC_MULTIPLIER: 4,
  EASE_ADJUSTMENT: 2,
} as const;

/**
 * Animation configuration interface
 */
export interface AnimationConfig {
  duration: number;
  easing: (_t: number) => number;
  onUpdate?: (_value: number) => void;
  onComplete?: () => void;
}

/**
 * Easing functions for animations
 */
export const easingFunctions = {
  linear: (t: number) => t,
  easeInOut: (t: number) => t < ANIMATION_CONSTANTS.HALF_POINT ? ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER * t * t : -1 + (ANIMATION_CONSTANTS.CUBIC_MULTIPLIER - ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER * t) * t,
  easeOut: (t: number) => t * (ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER - t),
  easeIn: (t: number) => t * t,
  easeInCubic: (t: number) => t * t * t,
  easeOutCubic: (t: number) => {
    const adjustedT = t - 1;
    return adjustedT * adjustedT * adjustedT + 1;
  },
  easeInOutCubic: (t: number) => t < ANIMATION_CONSTANTS.HALF_POINT ? ANIMATION_CONSTANTS.CUBIC_MULTIPLIER * t * t * t : (t - 1) * (ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER * t - ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER) * (ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER * t - ANIMATION_CONSTANTS.DOUBLE_MULTIPLIER) + 1,
};

/**
 * Format number with separators
 */
export function formatNumber(
  value: number,
  options: {
    decimals?: number;
    separator?: string;
    prefix?: string;
    suffix?: string;
  } = {}
): string {
  const {
    decimals = 0,
    separator = ',',
    prefix = '',
    suffix = ''
  } = options;

  const formattedValue = value.toFixed(decimals);
  const parts = formattedValue.split('.');

  // Add thousand separators - using safe static regex pattern
  // eslint-disable-next-line security/detect-unsafe-regex
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator);

  return prefix + parts.join('.') + suffix;
}

/**
 * Animation utilities for performance and compatibility
 */
export const animationUtils = {
  getTime: () => {
    if (typeof performance !== 'undefined' && performance.now) {
      return performance.now();
    }
    return Date.now();
  },

  scheduleFrame: (callback: (_time: number) => void) => {
    if (typeof requestAnimationFrame !== 'undefined') {
      return requestAnimationFrame(callback);
    }
    // Fallback to setTimeout for environments without requestAnimationFrame
    const FRAME_DURATION = 16; // 16ms for 60fps
    return setTimeout(() => callback(animationUtils.getTime()), FRAME_DURATION) as unknown as number;
  },

  cancelFrame: (id: number) => {
    if (typeof cancelAnimationFrame !== 'undefined') {
      cancelAnimationFrame(id);
    } else {
      clearTimeout(id);
    }
  }
};

/**
 * Animation hook for counter values
 */
export function useCounterAnimation(
  targetValue: number,
  config: AnimationConfig
) {
  const [currentValue, setCurrentValue] = React.useState(0);
  const animationRef = React.useRef<number | null>(null);
  const startTimeRef = React.useRef<number | null>(null);
  const startValueRef = React.useRef(0);

  const animate = React.useCallback((timestamp: number) => {
    if (startTimeRef.current === null) {
      startTimeRef.current = timestamp;
      startValueRef.current = currentValue;
    }

    const elapsed = timestamp - startTimeRef.current;
    const progress = Math.min(elapsed / config.duration, 1);
    const easedProgress = config.easing(progress);

    const newValue = startValueRef.current + (targetValue - startValueRef.current) * easedProgress;

    setCurrentValue(newValue);
    config.onUpdate?.(newValue);

    if (progress < 1) {
      animationRef.current = requestAnimationFrame(animate);
    } else {
      config.onComplete?.();
      animationRef.current = null;
      startTimeRef.current = null;
    }
  }, [targetValue, config, currentValue]);

  React.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }

    startTimeRef.current = null;
    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [animate]);

  return currentValue;
}

/**
 * Get current time for animation
 */
export function getCurrentTime(): number {
  if (typeof performance !== 'undefined' && performance.now) {
    return performance.now();
  }
  return Date.now();
}

/**
 * Schedule animation frame with fallback
 */
export function scheduleAnimationFrame(callback: (_time: number) => void): number {
  if (typeof requestAnimationFrame !== 'undefined') {
    return requestAnimationFrame(callback);
  }
  // Fallback to setTimeout for environments without requestAnimationFrame
  const FRAME_DURATION = 16; // 16ms for 60fps
  return setTimeout(() => callback(getCurrentTime()), FRAME_DURATION) as unknown as number;
}

/**
 * Cancel animation frame with fallback
 */
export function cancelAnimationFrame(id: number): void {
  if (typeof window !== 'undefined' && window.cancelAnimationFrame) {
    window.cancelAnimationFrame(id);
  } else {
    clearTimeout(id);
  }
}
